# Certification Authority
Setup the [command line tool](https://smallstep.com/docs/step-cli/installation/):
```
brew install step
```
And following the [basic crypto operations document](https://smallstep.com/docs/step-cli/basic-crypto-operations/)... set a random name for the CA or decide one:
```shell
# the 'names' command generates random names
set CA_NAME (names)
```
```shell
mkdir {$CA_NAME} ; set CA_ROOT (pwd)/{$CA_NAME} ; cd {$CA_ROOT}
```
Create the certificate and key for the root authority:
```shell 
step certificate create --profile root-ca {$CA_NAME}" Root CA" \
	{$CA_NAME}_root_ca.crt {$CA_NAME}_root_ca.key
```
And for the intermediate CA:
```shell
step certificate create {$CA_NAME}" Intermediate CA 1" \
    {$CA_NAME}_intermediate_ca_one.crt \
    {$CA_NAME}_intermediate_ca_one.key \
    --profile intermediate-ca \
    --ca ./{$CA_NAME}_root_ca.crt \
    --ca-key ./{$CA_NAME}_root_ca.key
```
Construct a CA bundle, some command line tools need this:
```
cat {$CA_NAME}_intermediate_ca_one.crt \
	{$CA_NAME}_root_ca.crt >> {$CA_NAME}_ca_bundle.crt
```
Issue a certificate for the Caddy server running at {$SERVER_NAME}:
```shell
step certificate create {$SERVER_NAME} \
	{$SERVER_NAME}.crt {$SERVER_NAME}.key \
    --profile leaf --not-after=8760h \
    --ca ./{$CA_NAME}_intermediate_ca_one.crt \
    --ca-key ./{$CA_NAME}_intermediate_ca_one.key \
    --bundle
```
And decrypt the key to install in the Caddy config:
```shell
openssl ec -in {$SERVER_NAME}.key -out {$SERVER_NAME}_unsecure.key
```

Install the authority into the system store or web browser store. 
```shell
# show info in Keychain and change Trust settings to 'Always Trust'
open {$CA_NAME}_root_ca.crt
```
```shell
# change Trust settings
open {$CA_NAME}_intermediate_ca_one.crt
```

Now copy the server certificate and key to the API Platform _ca_ folder and change the _Caddyfile_.

```shell
cp {$CA_ROOT}/{$SERVER_NAME}* {$AP_ROOT}/api/docker/ca
```
# WireGuard
This _kind of_ works but is not as straightforward as the Tailscale solution. It involves a [WireGuard server](https://github.com/linuxserver/docker-wireguard) image, a [DNS server](https://github.com/pi-hole/docker-pi-hole) and a lot of doubts.

I'll keep notes here as I try to understand how this works.

## Notes

I create a network for the peers and server:
```shell
docker network create --driver=bridge --opt com.docker.network.driver.mtu=1500 --subnet=172.29.0.0/16 --ip-range=172.29.5.0/24 apvpn
```

The server is configured to publish the port in the host, and to use the DNS running there too.
```yaml
---
version: "3.8"

services:
  wireguard:
    image: lscr.io/linuxserver/wireguard:latest
    cap_add:
      - NET_ADMIN
      - SYS_MODULE #optional
    environment:
      - PUID=1000
      - PGID=1000
      - TZ=Europe/Madrid
      - LOG_CONFS=true #optional
      - PEERS=shodan,caddy,mercure,ios
      - INTERNAL_SUBNET=10.24.24.0/24
      - PERSISTENTKEEPALIVE_PEERS=shodan,caddy,mercure,ios
      - PEERDNS=host.orb.internal
      - SERVERPORT=51820
      - SERVERURL=host.orb.internal
      # 198.19.248.254
      - ALLOWEDIPS=10.24.24.0/24
    volumes:
      - ./config:/config
    ports:
      - 51820:51820/udp
    sysctls:
      - net.ipv4.conf.all.src_valid_mark=1
    restart: unless-stopped

networks:
  default:
    name: apvpn
    external: true
    driver: bridge
    driver_opts:
      com.docker.network.driver.mtu: 1500
```

Now start it up and review the server configuration:
```shell
docker compose exec --privileged wireguard sh
```

```shell
wg
```

Get another image into the network; I'm using a different network for all services in the API Platform docker-compose and include the _caddy_ service into the _apvpn_ network.

Note this is not the current config used in this example project.

```yaml
version: "3.4"

services:
  php:
    image: ${IMAGES_PREFIX}-app-php:${IMAGES_VERSION}
    networks:
      - apback
# ...

  pwa:
    image: ${IMAGES_PREFIX}-app-pwa:${IMAGES_VERSION}
    networks:
      - apback
    environment:
      NEXT_PUBLIC_ENTRYPOINT: http://caddy

  caddy:
    image: ${IMAGES_PREFIX}-app-caddy:${IMAGES_VERSION}
    networks:
      - apback
      - apvpn
    cap_add:
      - NET_ADMIN
      - SYS_MODULE
    depends_on:
      - php
      - pwa
# ...

  database:
    image: postgres:${POSTGRES_VERSION:-15}-alpine
    networks:
      - apback
# ...

networks:
  apback:
    external: true
  apvpn:
    external: true

volumes:
# ...
```

Now enter the _caddy_ service and setup the vpn:
```shell
docker compose exec --privileged caddy sh
apk add wireguard-tools
cd /etc/wireguard
```

Get the peer configuration generated by the server image into the _caddy_ service as _wg0.conf_ and review/change it.
```shell
cat wg0.conf
[Interface]
Address = 10.24.24.6
PrivateKey = ...
ListenPort = 51820
DNS = host.orb.internal

[Peer]
PublicKey = ...
PresharedKey = ...
Endpoint = 172.29.5.2:51820
AllowedIPs = 10.24.24.0/24
```

Notice I'm using the _wireguard_ service address in the _apvpn_ network as endpoint; the _caddy_ service is also in that network. The DNS is set to the OrbStack name for the host, but I'm not sure about this one.

Start the interface:
```shell
wg-quick up wg0
wg
```

And ping the _wireguard_ service:
```shell
ping 172.29.5.2
```

Now move to the _wireguard_ s


# Test: Tailscale
Open a privileged shell into the _caddy_ service to install Tailscale into it.
```
docker compose exec --privileged caddy sh
apk add tailscale
tailscaled --tun=userspace-networking --socks5-server=localhost:1055 &
tailscale up
```
Login in the web browser and change the name of the machine in the Tailscale admin web to the ${SERVER_NAME}.